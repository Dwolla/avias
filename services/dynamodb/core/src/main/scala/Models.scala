package org.lyranthe.araethura.dynamodb.models
import org.lyranthe.araethura.dynamodb.models
final case class TableDescription(tableName: scala.Option[java.lang.String] = None, tableSizeBytes: scala.Option[scala.Long] = None, itemCount: scala.Option[scala.Long] = None, tableArn: scala.Option[java.lang.String] = None, latestStreamLabel: scala.Option[java.lang.String] = None, localSecondaryIndexes: scala.Option[scala.List[models.LocalSecondaryIndexDescription]] = None, globalSecondaryIndexes: scala.Option[scala.List[models.GlobalSecondaryIndexDescription]] = None, latestStreamArn: scala.Option[java.lang.String] = None, provisionedThroughput: scala.Option[models.ProvisionedThroughputDescription] = None, tableStatus: scala.Option[java.lang.String] = None, attributeDefinitions: scala.Option[scala.List[models.AttributeDefinition]] = None, keySchema: scala.Option[scala.List[models.KeySchemaElement]] = None, creationDateTime: scala.Option[java.time.Instant] = None, streamSpecification: scala.Option[models.StreamSpecification] = None)
final case class ListTagsOfResourceInput(resourceArn: java.lang.String, nextToken: scala.Option[java.lang.String] = None)
final case class ProvisionedThroughput(readCapacityUnits: scala.Long, writeCapacityUnits: scala.Long)
final case class GlobalSecondaryIndex(indexName: java.lang.String, keySchema: scala.List[models.KeySchemaElement], projection: models.Projection, provisionedThroughput: models.ProvisionedThroughput)
final case class ScanInput(tableName: java.lang.String, limit: scala.Option[scala.Int] = None, projectionExpression: scala.Option[java.lang.String] = None, expressionAttributeValues: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, consistentRead: scala.Option[scala.Boolean] = None, filterExpression: scala.Option[java.lang.String] = None, returnConsumedCapacity: scala.Option[java.lang.String] = None, select: scala.Option[java.lang.String] = None, totalSegments: scala.Option[scala.Int] = None, indexName: scala.Option[java.lang.String] = None, exclusiveStartKey: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, scanFilter: scala.Option[scala.collection.immutable.Map[java.lang.String, models.Condition]] = None, attributesToGet: scala.Option[scala.List[java.lang.String]] = None, segment: scala.Option[scala.Int] = None, expressionAttributeNames: scala.Option[scala.collection.immutable.Map[java.lang.String, java.lang.String]] = None, conditionalOperator: scala.Option[java.lang.String] = None)
final case class TagResourceInput(resourceArn: java.lang.String, tags: scala.List[models.Tag])
final case class DeleteTableOutput(tableDescription: scala.Option[models.TableDescription] = None)
final case class QueryInput(tableName: java.lang.String, keyConditionExpression: scala.Option[java.lang.String] = None, limit: scala.Option[scala.Int] = None, projectionExpression: scala.Option[java.lang.String] = None, expressionAttributeValues: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, consistentRead: scala.Option[scala.Boolean] = None, filterExpression: scala.Option[java.lang.String] = None, returnConsumedCapacity: scala.Option[java.lang.String] = None, select: scala.Option[java.lang.String] = None, indexName: scala.Option[java.lang.String] = None, exclusiveStartKey: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, scanIndexForward: scala.Option[scala.Boolean] = None, queryFilter: scala.Option[scala.collection.immutable.Map[java.lang.String, models.Condition]] = None, keyConditions: scala.Option[scala.collection.immutable.Map[java.lang.String, models.Condition]] = None, attributesToGet: scala.Option[scala.List[java.lang.String]] = None, expressionAttributeNames: scala.Option[scala.collection.immutable.Map[java.lang.String, java.lang.String]] = None, conditionalOperator: scala.Option[java.lang.String] = None)
final case class ExpectedAttributeValue(value: scala.Option[models.AttributeValue] = None, exists: scala.Option[scala.Boolean] = None, comparisonOperator: scala.Option[java.lang.String] = None, attributeValueList: scala.Option[scala.List[models.AttributeValue]] = None)
final case class ListTagsOfResourceOutput(tags: scala.Option[scala.List[models.Tag]] = None, nextToken: scala.Option[java.lang.String] = None)
final case class DescribeTableInput(tableName: java.lang.String)
final case class ListTablesInput(exclusiveStartTableName: scala.Option[java.lang.String] = None, limit: scala.Option[scala.Int] = None)
final case class DescribeTimeToLiveInput(tableName: java.lang.String)
final case class ItemCollectionMetrics(itemCollectionKey: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, sizeEstimateRangeGB: scala.Option[scala.List[scala.Double]] = None)
final case class ResourceInUseException(message: scala.Option[java.lang.String] = None)
final case class LocalSecondaryIndexDescription(indexSizeBytes: scala.Option[scala.Long] = None, itemCount: scala.Option[scala.Long] = None, indexArn: scala.Option[java.lang.String] = None, indexName: scala.Option[java.lang.String] = None, keySchema: scala.Option[scala.List[models.KeySchemaElement]] = None, projection: scala.Option[models.Projection] = None)
final case class WriteRequest(putRequest: scala.Option[models.PutRequest] = None, deleteRequest: scala.Option[models.DeleteRequest] = None)
final case class KeySchemaElement(attributeName: java.lang.String, keyType: java.lang.String)
final case class DeleteItemInput(tableName: java.lang.String, key: scala.collection.immutable.Map[java.lang.String, models.AttributeValue], expected: scala.Option[scala.collection.immutable.Map[java.lang.String, models.ExpectedAttributeValue]] = None, expressionAttributeValues: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, conditionExpression: scala.Option[java.lang.String] = None, returnConsumedCapacity: scala.Option[java.lang.String] = None, returnItemCollectionMetrics: scala.Option[java.lang.String] = None, returnValues: scala.Option[java.lang.String] = None, expressionAttributeNames: scala.Option[scala.collection.immutable.Map[java.lang.String, java.lang.String]] = None, conditionalOperator: scala.Option[java.lang.String] = None)
final case class CreateGlobalSecondaryIndexAction(indexName: java.lang.String, keySchema: scala.List[models.KeySchemaElement], projection: models.Projection, provisionedThroughput: models.ProvisionedThroughput)
final case class ProvisionedThroughputDescription(lastIncreaseDateTime: scala.Option[java.time.Instant] = None, lastDecreaseDateTime: scala.Option[java.time.Instant] = None, numberOfDecreasesToday: scala.Option[scala.Long] = None, readCapacityUnits: scala.Option[scala.Long] = None, writeCapacityUnits: scala.Option[scala.Long] = None)
final case class AttributeDefinition(attributeName: java.lang.String, attributeType: java.lang.String)
final case class ConditionalCheckFailedException(message: scala.Option[java.lang.String] = None)
final case class DescribeLimitsOutput(accountMaxReadCapacityUnits: scala.Option[scala.Long] = None, accountMaxWriteCapacityUnits: scala.Option[scala.Long] = None, tableMaxReadCapacityUnits: scala.Option[scala.Long] = None, tableMaxWriteCapacityUnits: scala.Option[scala.Long] = None)
final case class ListTablesOutput(tableNames: scala.Option[scala.List[java.lang.String]] = None, lastEvaluatedTableName: scala.Option[java.lang.String] = None)
final case class LocalSecondaryIndex(indexName: java.lang.String, keySchema: scala.List[models.KeySchemaElement], projection: models.Projection)
final case class UpdateItemOutput(attributes: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, consumedCapacity: scala.Option[models.ConsumedCapacity] = None, itemCollectionMetrics: scala.Option[models.ItemCollectionMetrics] = None)
final case class DeleteRequest(key: scala.collection.immutable.Map[java.lang.String, models.AttributeValue])
final case class BatchGetItemInput(requestItems: scala.collection.immutable.Map[java.lang.String, models.KeysAndAttributes], returnConsumedCapacity: scala.Option[java.lang.String] = None)
final case class UpdateTimeToLiveOutput(timeToLiveSpecification: scala.Option[models.TimeToLiveSpecification] = None)
final case class QueryOutput(items: scala.Option[scala.List[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]]] = None, count: scala.Option[scala.Int] = None, scannedCount: scala.Option[scala.Int] = None, lastEvaluatedKey: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, consumedCapacity: scala.Option[models.ConsumedCapacity] = None)
final case class PutRequest(item: scala.collection.immutable.Map[java.lang.String, models.AttributeValue])
final case class CreateTableInput(provisionedThroughput: models.ProvisionedThroughput, tableName: java.lang.String, attributeDefinitions: scala.List[models.AttributeDefinition], keySchema: scala.List[models.KeySchemaElement], globalSecondaryIndexes: scala.Option[scala.List[models.GlobalSecondaryIndex]] = None, localSecondaryIndexes: scala.Option[scala.List[models.LocalSecondaryIndex]] = None, streamSpecification: scala.Option[models.StreamSpecification] = None)
case object DescribeLimitsInput
final case class GlobalSecondaryIndexUpdate(update: scala.Option[models.UpdateGlobalSecondaryIndexAction] = None, create: scala.Option[models.CreateGlobalSecondaryIndexAction] = None, delete: scala.Option[models.DeleteGlobalSecondaryIndexAction] = None)
final case class KeysAndAttributes(keys: scala.List[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]], projectionExpression: scala.Option[java.lang.String] = None, consistentRead: scala.Option[scala.Boolean] = None, attributesToGet: scala.Option[scala.List[java.lang.String]] = None, expressionAttributeNames: scala.Option[scala.collection.immutable.Map[java.lang.String, java.lang.String]] = None)
final case class Condition(comparisonOperator: java.lang.String, attributeValueList: scala.Option[scala.List[models.AttributeValue]] = None)
final case class PutItemInput(item: scala.collection.immutable.Map[java.lang.String, models.AttributeValue], tableName: java.lang.String, expected: scala.Option[scala.collection.immutable.Map[java.lang.String, models.ExpectedAttributeValue]] = None, expressionAttributeValues: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, conditionExpression: scala.Option[java.lang.String] = None, returnConsumedCapacity: scala.Option[java.lang.String] = None, returnItemCollectionMetrics: scala.Option[java.lang.String] = None, returnValues: scala.Option[java.lang.String] = None, expressionAttributeNames: scala.Option[scala.collection.immutable.Map[java.lang.String, java.lang.String]] = None, conditionalOperator: scala.Option[java.lang.String] = None)
final case class ProvisionedThroughputExceededException(message: scala.Option[java.lang.String] = None)
final case class UpdateTableOutput(tableDescription: scala.Option[models.TableDescription] = None)
final case class BatchWriteItemOutput(unprocessedItems: scala.Option[scala.collection.immutable.Map[java.lang.String, scala.List[models.WriteRequest]]] = None, itemCollectionMetrics: scala.Option[scala.collection.immutable.Map[java.lang.String, scala.List[models.ItemCollectionMetrics]]] = None, consumedCapacity: scala.Option[scala.List[models.ConsumedCapacity]] = None)
final case class DescribeTimeToLiveOutput(timeToLiveDescription: scala.Option[models.TimeToLiveDescription] = None)
final case class DeleteItemOutput(attributes: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, consumedCapacity: scala.Option[models.ConsumedCapacity] = None, itemCollectionMetrics: scala.Option[models.ItemCollectionMetrics] = None)
final case class GlobalSecondaryIndexDescription(indexSizeBytes: scala.Option[scala.Long] = None, itemCount: scala.Option[scala.Long] = None, indexArn: scala.Option[java.lang.String] = None, provisionedThroughput: scala.Option[models.ProvisionedThroughputDescription] = None, indexName: scala.Option[java.lang.String] = None, backfilling: scala.Option[scala.Boolean] = None, indexStatus: scala.Option[java.lang.String] = None, keySchema: scala.Option[scala.List[models.KeySchemaElement]] = None, projection: scala.Option[models.Projection] = None)
final case class UpdateTableInput(tableName: java.lang.String, globalSecondaryIndexUpdates: scala.Option[scala.List[models.GlobalSecondaryIndexUpdate]] = None, provisionedThroughput: scala.Option[models.ProvisionedThroughput] = None, attributeDefinitions: scala.Option[scala.List[models.AttributeDefinition]] = None, streamSpecification: scala.Option[models.StreamSpecification] = None)
final case class TimeToLiveSpecification(enabled: scala.Boolean, attributeName: java.lang.String)
final case class Projection(projectionType: scala.Option[java.lang.String] = None, nonKeyAttributes: scala.Option[scala.List[java.lang.String]] = None)
final case class UpdateGlobalSecondaryIndexAction(indexName: java.lang.String, provisionedThroughput: models.ProvisionedThroughput)
final case class PutItemOutput(attributes: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, consumedCapacity: scala.Option[models.ConsumedCapacity] = None, itemCollectionMetrics: scala.Option[models.ItemCollectionMetrics] = None)
final case class DeleteTableInput(tableName: java.lang.String)
final case class ScanOutput(items: scala.Option[scala.List[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]]] = None, count: scala.Option[scala.Int] = None, scannedCount: scala.Option[scala.Int] = None, lastEvaluatedKey: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, consumedCapacity: scala.Option[models.ConsumedCapacity] = None)
final case class CreateTableOutput(tableDescription: scala.Option[models.TableDescription] = None)
final case class ResourceNotFoundException(message: scala.Option[java.lang.String] = None)
final case class BatchWriteItemInput(requestItems: scala.collection.immutable.Map[java.lang.String, scala.List[models.WriteRequest]], returnConsumedCapacity: scala.Option[java.lang.String] = None, returnItemCollectionMetrics: scala.Option[java.lang.String] = None)
final case class UpdateTimeToLiveInput(tableName: java.lang.String, timeToLiveSpecification: models.TimeToLiveSpecification)
final case class GetItemInput(tableName: java.lang.String, key: scala.collection.immutable.Map[java.lang.String, models.AttributeValue], projectionExpression: scala.Option[java.lang.String] = None, consistentRead: scala.Option[scala.Boolean] = None, returnConsumedCapacity: scala.Option[java.lang.String] = None, attributesToGet: scala.Option[scala.List[java.lang.String]] = None, expressionAttributeNames: scala.Option[scala.collection.immutable.Map[java.lang.String, java.lang.String]] = None)
final case class Tag(key: java.lang.String, value: java.lang.String)
final case class ConsumedCapacity(tableName: scala.Option[java.lang.String] = None, capacityUnits: scala.Option[scala.Double] = None, table: scala.Option[models.Capacity] = None, localSecondaryIndexes: scala.Option[scala.collection.immutable.Map[java.lang.String, models.Capacity]] = None, globalSecondaryIndexes: scala.Option[scala.collection.immutable.Map[java.lang.String, models.Capacity]] = None)
final case class DescribeTableOutput(table: scala.Option[models.TableDescription] = None)
final case class LimitExceededException(message: scala.Option[java.lang.String] = None)
final case class AttributeValueUpdate(value: scala.Option[models.AttributeValue] = None, action: scala.Option[java.lang.String] = None)
final case class DeleteGlobalSecondaryIndexAction(indexName: java.lang.String)
final case class InternalServerError(message: scala.Option[java.lang.String] = None)
final case class TimeToLiveDescription(timeToLiveStatus: scala.Option[java.lang.String] = None, attributeName: scala.Option[java.lang.String] = None)
final case class UpdateItemInput(tableName: java.lang.String, key: scala.collection.immutable.Map[java.lang.String, models.AttributeValue], expected: scala.Option[scala.collection.immutable.Map[java.lang.String, models.ExpectedAttributeValue]] = None, expressionAttributeValues: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, conditionExpression: scala.Option[java.lang.String] = None, returnConsumedCapacity: scala.Option[java.lang.String] = None, updateExpression: scala.Option[java.lang.String] = None, returnItemCollectionMetrics: scala.Option[java.lang.String] = None, returnValues: scala.Option[java.lang.String] = None, attributeUpdates: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValueUpdate]] = None, expressionAttributeNames: scala.Option[scala.collection.immutable.Map[java.lang.String, java.lang.String]] = None, conditionalOperator: scala.Option[java.lang.String] = None)
final case class StreamSpecification(streamEnabled: scala.Option[scala.Boolean] = None, streamViewType: scala.Option[java.lang.String] = None)
final case class GetItemOutput(item: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, consumedCapacity: scala.Option[models.ConsumedCapacity] = None)
final case class ItemCollectionSizeLimitExceededException(message: scala.Option[java.lang.String] = None)
final case class Capacity(capacityUnits: scala.Option[scala.Double] = None)
final case class BatchGetItemOutput(responses: scala.Option[scala.collection.immutable.Map[java.lang.String, scala.List[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]]]] = None, unprocessedKeys: scala.Option[scala.collection.immutable.Map[java.lang.String, models.KeysAndAttributes]] = None, consumedCapacity: scala.Option[scala.List[models.ConsumedCapacity]] = None)
final case class UntagResourceInput(resourceArn: java.lang.String, tagKeys: scala.List[java.lang.String])
final case class AttributeValue(bs: scala.Option[scala.List[scala.Array[scala.Byte]]] = None, ss: scala.Option[scala.List[java.lang.String]] = None, m: scala.Option[scala.collection.immutable.Map[java.lang.String, models.AttributeValue]] = None, `null`: scala.Option[scala.Boolean] = None, b: scala.Option[scala.Array[scala.Byte]] = None, s: scala.Option[java.lang.String] = None, n: scala.Option[java.lang.String] = None, ns: scala.Option[scala.List[java.lang.String]] = None, bool: scala.Option[scala.Boolean] = None, l: scala.Option[scala.List[models.AttributeValue]] = None)